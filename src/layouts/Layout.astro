---
import ConfigCarrier from "@components/ConfigCarrier.astro";
import MusicPlayer from "@components/widget/MusicPlayer.svelte";
import Pio from "@components/widget/Pio.svelte"; // Sử dụng phiên bản Svelte của thành phần Pio.
import {
	musicPlayerConfig,
	pioConfig,
	profileConfig,
	siteConfig,
} from "@/config";
import { umamiConfig } from "../config";

const BANNER_HEIGHT = 35;
const BANNER_HEIGHT_EXTEND = 30;
const BANNER_HEIGHT_HOME = BANNER_HEIGHT + BANNER_HEIGHT_EXTEND;

import {
	DARK_MODE,
	DEFAULT_THEME,
	LIGHT_MODE,
	PAGE_WIDTH,
} from "../constants/constants";
import { defaultFavicons } from "../constants/icon";
import type { Favicon } from "../types/config";
import { pathsEqual, url } from "../utils/url-utils";
import "../styles/mobile-navbar.css";
import "../styles/wallpaper-navbar-transparent.css";
import "../styles/fancybox-custom.css";
import "../styles/expressive-code.css";
import "../styles/panel-animations.css";

interface Props {
	title?: string;
	banner?: string;
	description?: string;
	lang?: string;
	setOGTypeArticle?: boolean;
	postSlug?: string;
}

let { title, banner, description, lang, setOGTypeArticle, postSlug } =
	Astro.props;

// apply a class to the body element to decide the height of the banner, only used for initial page load
// Swup can update the body for each page visit, but it's after the page transition, causing a delay for banner height change
// so use Swup hooks instead to change the height immediately when a link is clicked
const isHomePage = pathsEqual(Astro.url.pathname, url("/"));

// defines global css variables
// why doing this in Layout instead of GlobalStyles: https://github.com/withastro/astro/issues/6728#issuecomment-1502203757
const configHue = siteConfig.themeColor.hue;

// 获取导航栏透明模式配置
const navbarTransparentMode =
	siteConfig.banner?.navbar?.transparentMode || "semi";

// 判断是否应该显示顶部高光效果（只在full和semifull模式下显示）
const shouldShowTopHighlight =
	navbarTransparentMode === "full" || navbarTransparentMode === "semifull";

// 获取默认banner图片的辅助函数
const getDefaultBanner = (): string => {
	const src = siteConfig.banner.src;
	if (typeof src === "string") {
		return src;
	}
	if (Array.isArray(src)) {
		return src[0] || "";
	}
	if (src && typeof src === "object") {
		// 优先使用desktop，如果没有则使用mobile
		const desktopSrc = src.desktop;
		const mobileSrc = src.mobile;
		if (typeof desktopSrc === "string") {
			return desktopSrc;
		}
		if (Array.isArray(desktopSrc) && desktopSrc.length > 0) {
			return desktopSrc[0];
		}
		if (typeof mobileSrc === "string") {
			return mobileSrc;
		}
		if (Array.isArray(mobileSrc) && mobileSrc.length > 0) {
			return mobileSrc[0];
		}
	}
	return "";
};

if (!banner || typeof banner !== "string" || banner.trim() === "") {
	banner = getDefaultBanner();
}

// TODO don't use post cover as banner for now
banner = getDefaultBanner();

const enableBanner = !!siteConfig.banner.src;

let pageTitle: string;
if (title) {
	pageTitle = `${title} - ${siteConfig.title}`;
} else {
	pageTitle = siteConfig.subtitle
		? `${siteConfig.title} - ${siteConfig.subtitle}`
		: siteConfig.title;
}

let ogImageUrl: string | undefined;
if (siteConfig.generateOgImages && postSlug) {
	ogImageUrl = new URL(`/og/${postSlug}.png`, Astro.site).toString();
}

const favicons: Favicon[] =
	siteConfig.favicon.length > 0 ? siteConfig.favicon : defaultFavicons;

// const siteLang = siteConfig.lang.replace('_', '-')
if (!lang) {
	lang = `${siteConfig.lang}`;
}
const siteLang = lang.replace("_", "-");

const bannerOffsetByPosition = {
	top: `${BANNER_HEIGHT_EXTEND}vh`,
	center: `${BANNER_HEIGHT_EXTEND / 2}vh`,
	bottom: "0",
};
const bannerOffset =
	bannerOffsetByPosition[siteConfig.banner.position || "center"];

const umamiEnabled = umamiConfig.enabled || false;
const umamiScripts = umamiConfig.scripts || ""; // 获取Umami scripts配置

// 构建字体配置的 CSS 变量
// ASCII 字体优先级最高（用于英文、数字等），CJK 字体作为回退
let bodyFontFamily = "";
if (siteConfig.font) {
	const fonts: string[] = [];
	// 先添加 ASCII 字体（优先级最高）
	if (siteConfig.font.asciiFont?.fontFamily) {
		const asciiFont = siteConfig.font.asciiFont.fontFamily;
		// 如果字体名包含空格，需要用引号包围
		fonts.push(asciiFont.includes(" ") ? `"${asciiFont}"` : asciiFont);
	}
	// 再添加 CJK 字体（作为回退）
	if (siteConfig.font.cjkFont?.fontFamily) {
		const cjkFont = siteConfig.font.cjkFont.fontFamily;
		// 如果字体名包含空格，需要用引号包围
		fonts.push(cjkFont.includes(" ") ? `"${cjkFont}"` : cjkFont);
	}
	// 添加系统字体作为最终回退
	fonts.push(
		"system-ui",
		"-apple-system",
		"BlinkMacSystemFont",
		"'Segoe UI'",
		"Roboto",
		"Oxygen",
		"Ubuntu",
		"Cantarell",
		"'Open Sans'",
		"'Helvetica Neue'",
		"sans-serif",
	);
	// 组合成完整的 font-family 字符串
	bodyFontFamily = fonts.join(", ");
}
---

<!doctype html>
<html
	lang={siteLang}
	class="bg-[var(--page-bg)] text-[14px] md:text-[16px]"
	data-overlayscrollbars-initialize
>
	<head>
		<!--/ Script phân tích bên thứ ba - tối ưu tải trì hoãn (lazy load) /-->
		<script is:inline>
			// Sử dụng requestIdleCallback để trì hoãn tải script bên thứ ba
			function loadAnalytics() {
				// Google Tag Manager
				(function (w, d, s, l, i) {
					w[l] = w[l] || [];
					w[l].push({
						"gtm.start": new Date().getTime(),
						event: "gtm.js",
					});
					var f = d.getElementsByTagName(s)[0],
						j = d.createElement(s),
						dl = l != "dataLayer" ? "&l=" + l : "";
					j.async = true;
					j.src =
						"https://www.googletagmanager.com/gtm.js?id=" + i + dl;
					f.parentNode.insertBefore(j, f);
				})(window, document, "script", "dataLayer", "GTM-KRX3XGVH");

				// Clarity
				(function (c, l, a, r, i, t, y) {
					c[a] =
						c[a] ||
						function () {
							(c[a].q = c[a].q || []).push(arguments);
						};
					t = l.createElement(r);
					t.async = 1;
					t.src = "https://www.clarity.ms/tag/" + i;
					y = l.getElementsByTagName(r)[0];
					y.parentNode.insertBefore(t, y);
				})(window, document, "clarity", "script", "tjr3vkhj8i");
			}

			// Tải khi trình duyệt rảnh, hoặc sau 3 giây
			if ("requestIdleCallback" in window) {
				requestIdleCallback(loadAnalytics, { timeout: 3000 });
			} else {
				setTimeout(loadAnalytics, 3000);
			}
		</script>

		<title>{pageTitle}</title>
		<meta charset="UTF-8" />
		<meta name="description" content={description || pageTitle} />
		{
			siteConfig.keywords && siteConfig.keywords.length > 0 && (
				<meta
					name="keywords"
					content={siteConfig.keywords.join(", ")}
				/>
			)
		}
		<meta name="author" content={profileConfig.name} />
		<meta property="og:site_name" content={siteConfig.title} />
		<meta property="og:url" content={Astro.url} />
		<meta property="og:title" content={pageTitle} />
		<meta property="og:description" content={description || pageTitle} />
		{ogImageUrl && <meta property="og:image" content={ogImageUrl} />}
		{
			setOGTypeArticle ? (
				<meta property="og:type" content="article" />
			) : (
				<meta property="og:type" content="website" />
			)
		}
		<meta name="twitter:card" content="summary_large_image" />
		<meta property="twitter:url" content={Astro.url} />
		<meta name="twitter:title" content={pageTitle} />
		<meta name="twitter:description" content={description || pageTitle} />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		{
			favicons.map((favicon) => (
				<link
					rel="icon"
					href={
						favicon.src.startsWith("/")
							? url(favicon.src)
							: favicon.src
					}
					sizes={favicon.sizes}
					media={
						favicon.theme &&
						`(prefers-color-scheme: ${favicon.theme})`
					}
				/>
			))
		}

		<!-- Set the theme before the page is rendered to avoid a flash -->
		<script
			is:inline
			define:vars={{
				DEFAULT_THEME,
				LIGHT_MODE,
				DARK_MODE,
				BANNER_HEIGHT_EXTEND,
				PAGE_WIDTH,
				configHue,
				pageScaling: siteConfig.pageScaling,
			}}
		>
			// Load the theme from local storage
			const theme = localStorage.getItem("theme") || DEFAULT_THEME;
			let isDark = false;
			switch (theme) {
				case LIGHT_MODE:
					document.documentElement.classList.remove("dark");
					isDark = false;
					break;
				case DARK_MODE:
					document.documentElement.classList.add("dark");
					isDark = true;
					break;
			}

			// Set the theme for Expressive Code based on current mode
			const expressiveTheme = isDark ? "github-dark" : "github-light";
			const currentTheme =
				document.documentElement.getAttribute("data-theme");
			// Chỉ cập nhật khi giao diện thay đổi để tránh gây ra việc vẽ lại không cần thiết.
			if (currentTheme !== expressiveTheme) {
				document.documentElement.setAttribute(
					"data-theme",
					expressiveTheme,
				);
			}

			// Load the hue from local storage
			const hue = localStorage.getItem("hue") || configHue;
			document.documentElement.style.setProperty("--hue", hue);

			// calculate the --banner-height-extend, which needs to be a multiple of 4 to avoid blurry text
			let offset = Math.floor(
				window.innerHeight * (BANNER_HEIGHT_EXTEND / 100),
			);
			offset = offset - (offset % 4);
			document.documentElement.style.setProperty(
				"--banner-height-extend",
				`${offset}px`,
			);

			// Logic tự động co giãn (được chuyển từ MainGridLayout sang đây để chạy sớm hơn)
			(function() {
				if (pageScaling && pageScaling.enable) {
					function adjustPageScale() {
						const isTouch =
							(window.matchMedia &&
								(window.matchMedia("(pointer:coarse)").matches ||
									window.matchMedia("(hover: none)").matches)) ||
							("ontouchstart" in window);
						const isPortrait =
							window.matchMedia &&
							window.matchMedia("(orientation: portrait)").matches;
						const isTabletLike = isTouch || window.innerWidth <= 1280;
						if (isTabletLike || isPortrait) {
							document.documentElement.style.fontSize = "";
							return;
						}
						const targetWidth = pageScaling.targetWidth || 2000;
						const currentWidth = document.documentElement.clientWidth;
						let scale = currentWidth / targetWidth;
						if (scale > 1) scale = 1;
						if (scale < 0.85) scale = 0.85;
						document.documentElement.style.fontSize = `${scale * 100}%`;
					}

					// Thực thi ngay một lần
					adjustPageScale();
					
					// Lắng nghe thay đổi kích thước cửa sổ
					window.addEventListener('resize', adjustPageScale);
					
					// Cần kiểm tra lại sau khi Swup chuyển trang
					document.addEventListener('swup:page:view', adjustPageScale);
					window.addEventListener('orientationchange', adjustPageScale);
				}
			})();
		</script>
		<style
			define:vars={{
				configHue,
				"page-width": `${PAGE_WIDTH}rem`,
			}}
		></style>

		<!-- defines global css variables. This will be applied to <html> <body> and some other elements idk why -->
		<slot name="head" />

		<!-- / Style Pio (waifu) – chỉ tải khi được bật / -->
		{
			pioConfig.enable && (
				<link rel="stylesheet" href="/pio/static/pio.css" />
			)
		}

		<link
			rel="alternate"
			type="application/rss+xml"
			title={profileConfig.name}
			href={`${Astro.site}rss.xml`}
		/>

		<!-- Umami Analytics -->
		{umamiEnabled && umamiScripts && <Fragment set:html={umamiScripts} />}
	</head>
	<body
		class="min-h-screen"
		class:list={[
			{ "lg:is-home": isHomePage, "enable-banner": enableBanner },
		]}
		style={bodyFontFamily ? `font-family: ${bodyFontFamily};` : ""}
		data-overlayscrollbars-initialize
	>
		<noscript
			><iframe
				src="https://www.googletagmanager.com/ns.html?id=GTM-KRX3XGVH"
				height="0"
				width="0"
				style="display:none;visibility:hidden"></iframe></noscript
		>
		<!-- Hiệu ứng highlight gradient ở đầu trang – chỉ hiển thị trong chế độ full và semifull -->
		{shouldShowTopHighlight && <div class="top-gradient-highlight" />}

		<ConfigCarrier />
		<slot />

		<!-- Music Player – chỉ tải khi được bật -->
		{musicPlayerConfig.enable && <MusicPlayer client:idle />}

		<!-- Thành phần Pio (waifu) – chỉ tải khi được bật -->
		{pioConfig.enable && <Pio client:idle />}

		<!-- increase the page height during page transition to prevent the scrolling animation from jumping -->
		<div id="page-height-extend" class="hidden h-[300vh]"></div>
	</body>
</html>

<style
	is:global
	define:vars={{
		bannerOffset,
		"banner-height-home": `${BANNER_HEIGHT_HOME}vh`,
		"banner-height": `${BANNER_HEIGHT}vh`,
	}}
>
	@tailwind components;
	@layer components {
		.enable-banner.is-home #banner-wrapper {
			@apply h-[var(--banner-height-home)] translate-y-[var(--banner-height-extend)];
		}
		.enable-banner #banner-wrapper {
			@apply h-[var(--banner-height-home)];
		}
		.enable-banner.is-home #banner {
			@apply h-[var(--banner-height-home)] translate-y-0;
		}
		.enable-banner #banner {
			@apply h-[var(--banner-height-home)] translate-y-[var(--bannerOffset)];
		}
		.enable-banner.is-home #main-grid {
			@apply translate-y-[var(--banner-height-extend)];
		}
		.enable-banner #top-row {
			@apply h-[calc(var(--banner-height-home)_-_4.5rem)] transition-all duration-300;
		}
		.enable-banner.is-home #sidebar-sticky {
			@apply top-[calc(1rem_-_var(--banner-height-extend))];
		}
		.navbar-hidden {
			@apply opacity-0 -translate-y-16;
		}

		/* Water waves animation */
		.waves > .parallax use {
			animation: wave 25s cubic-bezier(0.5, 0.5, 0.45, 0.5) infinite;
		}
		@keyframes wave {
			0% {
				transform: translate3d(-90px, 0, 0);
			}
			100% {
				transform: translate3d(85px, 0, 0);
			}
		}
	}
</style>

<script>
	// import { animationManager } from '../utils/animation-utils';
	import "overlayscrollbars/overlayscrollbars.css";
	// import {
	//  OverlayScrollbars,
	//  // ScrollbarsHidingPlugin,
	//  // SizeObserverPlugin,
	//  // ClickScrollPlugin
	// } from 'overlayscrollbars';
	// import {getHue, getStoredTheme, setHue, setTheme} from "../utils/setting-utils";
	import { pathsEqual, url } from "../utils/url-utils";
	import {
		// BANNER_HEIGHT,
		// BANNER_HEIGHT_HOME,
		// BANNER_HEIGHT_EXTEND,
		// MAIN_PANEL_OVERLAPS_BANNER_HEIGHT,
		DARK_MODE,
		DEFAULT_THEME,
	} from "../constants/constants";

	const BANNER_HEIGHT = 35;
	const BANNER_HEIGHT_EXTEND = 30;
	const BANNER_HEIGHT_HOME = BANNER_HEIGHT + BANNER_HEIGHT_EXTEND;

	// const MAIN_PANEL_OVERLAPS_BANNER_HEIGHT = 3.5;
	import { siteConfig } from "../config";
	import { widgetConfigs } from "../config";
	import { initSakura } from "../utils/sakura-manager";

	// const setTimeout = window.setTimeout;
	// @ts-ignore
	const setTimeout = (callback: any, delay: any) =>
		window.setTimeout(callback, delay);

	/* Preload fonts */
	// (async function() {
	//  try {
	//      await Promise.all([
	//          document.fonts.load("400 1em Roboto"),
	//          document.fonts.load("700 1em Roboto"),
	//      ]);
	//      document.body.classList.remove("hidden");
	//  } catch (error) {
	//      console.log("Failed to load fonts:", error);
	//  }
	// })();

	/* TODO This is a temporary solution for style flicker issue when the transition is activated */
	/* issue link: https://github.com/withastro/astro/issues/8711, the solution get from here too */
	/* update: fixed in Astro 3.2.4 */
	/*
function disableAnimation() {
    const css = document.createElement('style')
    css.appendChild(
        document.createTextNode(
            `*{
              -webkit-transition:none!important;
              -moz-transition:none!important;
              -o-transition:none!important;
              -ms-transition:none!important;
              transition:none!important
              }`
        )
    )
    document.head.appendChild(css)

    return () => {
        // Force restyle
        ;(() => window.getComputedStyle(document.body))()
        // Wait for next tick before removing
        setTimeout(() => {
            document.head.removeChild(css)
        }, 1)
    }
}
*/

	const bannerEnabled = !!document.getElementById("banner-wrapper");

	// Import bộ quản lý panel
	async function initializePanelManager() {
		try {
			// @ts-ignore
			const { panelManager } = await import("../utils/panel-manager.js");

			function setClickOutsideToClose(panel: string, ignores: string[]) {
				document.addEventListener("click", async (event) => {
					// @ts-ignore
					// let _panelDom = document.getElementById(panel);
					let tDom = event.target;
					if (!(tDom instanceof Node)) return; // Ensure the event target is an HTML Node
					for (let ig of ignores) {
						let ie = document.getElementById(ig);
						if (ie == tDom || ie?.contains(tDom)) {
							return;
						}
					}
					await panelManager.closePanel(panel as any);
				});
			}

			setClickOutsideToClose("display-setting", [
				"display-setting",
				"display-settings-switch",
			]);
			setClickOutsideToClose("nav-menu-panel", [
				"nav-menu-panel",
				"nav-menu-switch",
			]);
			setClickOutsideToClose("search-panel", [
				"search-panel",
				"search-bar",
				"search-switch",
			]);
			setClickOutsideToClose("mobile-toc-panel", [
				"mobile-toc-panel",
				"mobile-toc-switch",
			]);
			setClickOutsideToClose("wallpaper-mode-panel", [
				"wallpaper-mode-panel",
				"wallpaper-mode-switch",
			]);

			return panelManager;
		} catch (error) {
			console.error("Failed to initialize panel manager:", error);
			return null;
		}
	}

	initializePanelManager();

	// function _loadTheme() {
	//  const theme = getStoredTheme()
	//  setTheme(theme)
	// }

	// function _loadHue() {
	//  setHue(getHue())
	// }

	function initCustomScrollbar() {
		// Vô hiệu hóa hoàn toàn việc khởi tạo OverlayScrollbars trên body để tránh gây reload trang
        // Chỉ xử lý thanh cuộn cho các phần tử KaTeX
		const katexElements = document.querySelectorAll(
			".katex-display:not([data-scrollbar-initialized])",
		) as NodeListOf<HTMLElement>;

		katexElements.forEach((element) => {
			if (!element.parentNode) return;

			const container = document.createElement("div");
			container.className = "katex-display-container";
			element.parentNode.insertBefore(container, element);
			container.appendChild(element);

			// Sử dụng thanh cuộn CSS đơn giản thay vì OverlayScrollbars
			container.style.cssText = `
            overflow-x: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(0,0,0,0.3) transparent;
        `;

			// Thêm style thanh cuộn tùy chỉnh cho trình duyệt WebKit
			const style = document.createElement("style");
			style.textContent = `
            .katex-display-container::-webkit-scrollbar {
                height: 6px;
            }
            .katex-display-container::-webkit-scrollbar-track {
                background: transparent;
            }
            .katex-display-container::-webkit-scrollbar-thumb {
                background: rgba(0,0,0,0.3);
                border-radius: 3px;
            }
            .katex-display-container::-webkit-scrollbar-thumb:hover {
                background: rgba(0,0,0,0.5);
            }
        `;

			if (!document.head.querySelector("style[data-katex-scrollbar]")) {
				style.setAttribute("data-katex-scrollbar", "true");
				document.head.appendChild(style);
			}

			element.setAttribute("data-scrollbar-initialized", "true");
		});
	}

	function showBanner() {
		// Sử dụng requestAnimationFrame để tối ưu thao tác DOM
		requestAnimationFrame(() => {
			// Handle single image banner (desktop)
			const banner = document.getElementById("banner");
			if (banner) {
				banner.classList.remove("opacity-0", "scale-105");
			}

			// Xử lý banner ảnh đơn trên mobile – sử dụng cùng logic như desktop
			const mobileBanner = document.querySelector(
				'.block.md\\:hidden[alt="Mobile banner image of the blog"]',
			);
			if (mobileBanner && !document.getElementById("banner-carousel")) {
				// Mobile sử dụng cùng logic khởi tạo như desktop
				mobileBanner.classList.remove("opacity-0", "scale-105");
				mobileBanner.classList.add("opacity-100");
			}

			// Xử lý banner carousel – khởi tạo ngay, bỏ trì hoãn
			const carousel = document.getElementById("banner-carousel");
			if (carousel) {
				// Khởi tạo carousel ngay lập tức, bỏ trì hoãn để cải thiện độ mượt
				initCarousel();
			}
		});
	}

	function initCarousel() {
		const carouselItems = document.querySelectorAll(".carousel-item");
		// Lọc các item carousel hợp lệ theo kích thước màn hình
		const isMobile = window.innerWidth < 768; // md breakpoint
		const validItems = Array.from(carouselItems).filter((item) => {
			if (isMobile) {
				// Mobile: chỉ hiển thị các item có ảnh mobile
				return item.querySelector(".block.md\\:hidden");
			} else {
				// Desktop/Tablet: chỉ hiển thị các item có ảnh desktop
				return item.querySelector(".hidden.md\\:block");
			}
		});

		if (validItems.length > 1 && siteConfig.banner.carousel?.enable) {
			let currentIndex = 0;
			const interval = siteConfig.banner.carousel?.interval || 6;
			let carouselInterval: any;
			let isPaused = false;

			// Hỗ trợ cử chỉ chạm trên mobile
			let startX = 0;
			let startY = 0;
			let isSwiping = false;

			const carousel = document.getElementById("banner-carousel");

			// Hàm chuyển đổi ảnh – dựa trên các item hợp lệ
			function switchToSlide(index: number) {
				// Ẩn ảnh hiện tại
				const currentItem = validItems[currentIndex];
				currentItem.classList.remove("opacity-100", "scale-100");
				currentItem.classList.add("opacity-0", "scale-110");

				// Cập nhật chỉ mục
				currentIndex = index;

				// Hiển thị ảnh mới
				const nextItem = validItems[currentIndex];
				nextItem.classList.add("opacity-100", "scale-100");
				nextItem.classList.remove("opacity-0", "scale-110");
			}

			// Khởi tạo: ẩn tất cả ảnh, chỉ hiển thị ảnh hợp lệ đầu tiên
			carouselItems.forEach((item) => {
				item.classList.add("opacity-0", "scale-110");
				item.classList.remove("opacity-100", "scale-100");
			});

			// Hiển thị ảnh hợp lệ đầu tiên
			if (validItems.length > 0) {
				validItems[0].classList.add("opacity-100", "scale-100");
				validItems[0].classList.remove("opacity-0", "scale-110");
			}

			// Sự kiện chạm trên mobile
			if (carousel && "ontouchstart" in window) {
				carousel.addEventListener(
					"touchstart",
					(e) => {
						startX = e.touches[0].clientX;
						startY = e.touches[0].clientY;
						isSwiping = false;
						isPaused = true;
						clearInterval(carouselInterval);
					},
					{ passive: true },
				);

				carousel.addEventListener(
					"touchmove",
					(e) => {
						if (!startX || !startY) return;

						const diffX = Math.abs(e.touches[0].clientX - startX);
						const diffY = Math.abs(e.touches[0].clientY - startY);

						// Kiểm tra xem có phải là vuốt ngang hay không
						if (diffX > diffY && diffX > 30) {
							isSwiping = true;
							e.preventDefault();
						}
					},
					{ passive: false },
				);

				carousel.addEventListener(
					"touchend",
					(e) => {
						if (!startX || !startY || !isSwiping) {
							isPaused = false;
							startCarousel();
							return;
						}

						const endX = e.changedTouches[0].clientX;
						const diffX = startX - endX;

						// Chỉ chuyển khi khoảng cách vuốt vượt quá 50px
						if (Math.abs(diffX) > 50) {
							if (diffX > 0) {
								// Vuốt sang trái, hiển thị ảnh tiếp theo
								const nextIndex =
									(currentIndex + 1) % validItems.length;
								switchToSlide(nextIndex);
							} else {
								// Vuốt sang phải, hiển thị ảnh trước đó
								const prevIndex =
									(currentIndex - 1 + validItems.length) %
									validItems.length;
								switchToSlide(prevIndex);
							}
						}

						startX = 0;
						startY = 0;
						isSwiping = false;
						isPaused = false;
						// Khởi động lại tự động chuyển ảnh
						startCarousel();
					},
					{ passive: true },
				);
			}

			// Hàm bắt đầu carousel
			function startCarousel() {
				clearInterval(carouselInterval);
				carouselInterval = setInterval(() => {
					if (!isPaused) {
						const nextIndex =
							(currentIndex + 1) % validItems.length;
						switchToSlide(nextIndex);
					}
				}, interval * 1000);
			}

			// Tạm dừng khi hover chuột (desktop)
			if (carousel) {
				carousel.addEventListener("mouseenter", () => {
					isPaused = true;
					clearInterval(carouselInterval);
				});
				carousel.addEventListener("mouseleave", () => {
					isPaused = false;
					startCarousel();
				});
			}

			// Bắt đầu tự động chuyển ảnh
			startCarousel();
		}
	}

	function setupSakura() {
		const sakuraConfig = (widgetConfigs as any)?.sakura;
		if (!sakuraConfig || !sakuraConfig.enable) return;
		if ((window as any).sakuraInitialized) return;
		initSakura(sakuraConfig);
		(window as any).sakuraInitialized = true;
	}

	if (document.readyState === "loading") {
		document.addEventListener("DOMContentLoaded", setupSakura);
	} else {
		setupSakura();
	}

	let fancyboxSelectors: string[] = [];
	let Fancybox: any;

	// Tải công thức toán học theo nhu cầu
	function checkKatex() {
		if (document.querySelector(".katex")) {
			import("katex/dist/katex.css");
		}
	}

	// Tải lightbox ảnh theo nhu cầu
	async function initFancybox() {
		const albumImagesSelector =
			".custom-md img, #post-cover img, .moment-images img";
		const albumLinksSelector = ".moment-images a[data-fancybox]";
		const singleFancyboxSelector = "[data-fancybox]:not(.moment-images a)";

		const hasImages =
			document.querySelector(albumImagesSelector) ||
			document.querySelector(albumLinksSelector) ||
			document.querySelector(singleFancyboxSelector);

		if (!hasImages) return;

		if (!Fancybox) {
			const mod = await import("@fancyapps/ui");
			Fancybox = mod.Fancybox;
			await import("@fancyapps/ui/dist/fancybox/fancybox.css");
		}

		if (fancyboxSelectors.length > 0) {
			return; // Đã được khởi tạo, trả về ngay
		}

		const commonConfig = {
			Thumbs: { autoStart: true, showOnStart: "yes" },
			Toolbar: {
				display: {
					left: ["infobar"],
					middle: [
						"zoomIn",
						"zoomOut",
						"toggle1to1",
						"rotateCCW",
						"rotateCW",
						"flipX",
						"flipY",
					],
					right: ["slideshow", "thumbs", "close"],
				},
			},
			animated: true,
			dragToClose: true,
			keyboard: {
				Escape: "close",
				Delete: "close",
				Backspace: "close",
				PageUp: "next",
				PageDown: "prev",
				ArrowUp: "next",
				ArrowDown: "prev",
				ArrowRight: "next",
				ArrowLeft: "prev",
			},
			fitToView: true,
			preload: 3,
			infinite: true,
			Panzoom: { maxScale: 3, minScale: 1 },
			caption: false,
		};

		// Liên kết ảnh album / ảnh bài viết
		Fancybox.bind(albumImagesSelector, {
			...commonConfig,
			groupAll: true,
			Carousel: {
				transition: "slide",
				preload: 2,
			},
		});
		fancyboxSelectors.push(albumImagesSelector);

		Fancybox.bind(albumLinksSelector, {
			...commonConfig,
			source: (el: any) => {
				return el.getAttribute("data-src") || el.getAttribute("href");
			},
		});
		fancyboxSelectors.push(albumLinksSelector);

		// Liên kết ảnh fancybox đơn lẻ
		Fancybox.bind(singleFancyboxSelector, commonConfig);
		fancyboxSelectors.push(singleFancyboxSelector);
	}

	// Dọn dẹp instance Fancybox
	function cleanupFancybox() {
		if (!Fancybox) return; // Nếu chưa từng được tải thì không cần dọn dẹp
		fancyboxSelectors.forEach((selector) => {
			Fancybox.unbind(selector);
		});
		fancyboxSelectors = [];
	}

	const setup = () => {
		// TODO: temp solution to change the height of the banner
		/*
    window.swup.hooks.on('animation:out:start', () => {
        const path = window.location.pathname
        const body = document.querySelector('body')
        if (path[path.length - 1] === '/' && !body.classList.contains('is-home')) {
            body.classList.add('is-home')
        } else if (path[path.length - 1] !== '/' && body.classList.contains('is-home')) {
            body.classList.remove('is-home')
        }
    })
*/
		window.swup.hooks.on("link:click", () => {
			// Remove the delay for the first time page load
			document.documentElement.style.setProperty(
				"--content-delay",
				"0ms",
			);

			// Đơn giản hóa logic xử lý navbar
			if (bannerEnabled) {
				const navbar = document.getElementById("navbar-wrapper");
				if (navbar && document.body.classList.contains("lg:is-home")) {
					const threshold =
						window.innerHeight * (BANNER_HEIGHT / 100) - 88;
					if (document.documentElement.scrollTop >= threshold) {
						navbar.classList.add("navbar-hidden");
					}
				}
			}
		});

		window.swup.hooks.on("content:replace", () => {
			// Khởi tạo ảnh, công thức, thanh cuộn và TOC cho trang mới
			initFancybox();
			checkKatex();
			initCustomScrollbar();

			// Kiểm tra trang hiện tại có phải là trang bài viết hay không (có phần tử TOC)
			const tocWrapper = document.getElementById("toc-wrapper");
			const isArticlePage = tocWrapper !== null;

			// Chỉ khởi tạo lại component TOC trên trang bài viết
			if (isArticlePage) {
				const tocElement = document.querySelector("table-of-contents");
				if (
					tocElement &&
					typeof (tocElement as any).init === "function"
				) {
					setTimeout(() => {
						(tocElement as any).init();
					}, 100);
				}

				// Khởi tạo lại component TOC cho mobile
				if (typeof (window as any).mobileTOCInit === "function") {
					setTimeout(() => {
						(window as any).mobileTOCInit();
					}, 100);
				}
			}

			// Khởi tạo lại phát hiện cuộn cho chế độ semifull
			const navbar = document.getElementById("navbar");
			if (navbar) {
				const transparentMode = navbar.getAttribute(
					"data-transparent-mode",
				);
				if (transparentMode === "semifull") {
					// Gọi lại hàm khởi tạo để gắn lại sự kiện cuộn
					if (
						typeof (window as any).initSemifullScrollDetection ===
						"function"
					) {
						(window as any).initSemifullScrollDetection();
					}
				}
			}
		});

		window.swup.hooks.on(
			"visit:start",
			(visit: { to: { url: string } }) => {
				// Dọn dẹp Fancybox của trang trước
				cleanupFancybox();

				// Xử lý class và trạng thái hiển thị của banner
				const bodyElement = document.querySelector("body");
				const isHomePage = pathsEqual(visit.to.url, url("/"));
				if (bodyElement) {
					if (isHomePage) {
						bodyElement.classList.add("lg:is-home");
					} else {
						bodyElement.classList.remove("lg:is-home");
					}
				}

				// Control banner text visibility based on page
				const bannerTextOverlay = document.querySelector(
					".banner-text-overlay",
				);
				if (bannerTextOverlay) {
					if (isHomePage) {
						bannerTextOverlay.classList.remove("hidden");
					} else {
						bannerTextOverlay.classList.add("hidden");
					}
				}

				// Control navbar transparency based on page
				const navbar = document.getElementById("navbar");
				if (navbar) {
					navbar.setAttribute("data-is-home", isHomePage.toString());
					// Khởi tạo lại phát hiện cuộn cho chế độ semifull
					const transparentMode = navbar.getAttribute(
						"data-transparent-mode",
					);
					if (transparentMode === "semifull") {
						// Gọi lại hàm khởi tạo để gắn lại sự kiện cuộn
						if (
							typeof (window as any)
								.initSemifullScrollDetection === "function"
						) {
							(window as any).initSemifullScrollDetection();
						}
					}
				}

				// Control mobile banner visibility based on page with improved staging animation
				const bannerWrapper = document.getElementById("banner-wrapper");
				const mainContentWrapper = document.querySelector(
					".absolute.w-full.z-30",
				);

				if (bannerWrapper && mainContentWrapper) {
					if (isHomePage) {
						// Trang chủ: trì hoãn việc bỏ class ẩn để banner và nội dung xuất hiện mượt mà
						setTimeout(() => {
							bannerWrapper.classList.remove(
								"mobile-hide-banner",
							);
						}, 100);
						setTimeout(() => {
							mainContentWrapper.classList.remove(
								"mobile-main-no-banner",
							);
						}, 150);
					} else {
						// Không phải trang chủ: ẩn theo từng giai đoạn, ẩn banner trước rồi mới di chuyển nội dung
                        bannerWrapper.classList.add("mobile-hide-banner");
                        // Trì hoãn việc di chuyển nội dung để banner biến mất hoàn toàn trước
						setTimeout(() => {
							mainContentWrapper.classList.add(
								"mobile-main-no-banner",
							);
						}, 100);
					}
				}

				// increase the page height during page transition to prevent the scrolling animation from jumping
				const heightExtend =
					document.getElementById("page-height-extend");
				if (heightExtend) {
					heightExtend.classList.remove("hidden");
				}

				// Hide the TOC while scrolling back to top
				let toc = document.getElementById("toc-wrapper");
				if (toc) {
					toc.classList.add("toc-not-ready");
				}
			},
		);

		window.swup.hooks.on("page:view", () => {
			// hide the temp high element when the transition is done
			const heightExtend = document.getElementById("page-height-extend");
			if (heightExtend) {
				heightExtend.classList.remove("hidden");
			}

			// 确保页面滚动到顶部，特别是移动端banner关闭时
			window.scrollTo({
				top: 0,
				behavior: "instant",
			});

			// 同步主题状态 - 解决从首页进入文章页面时代码块渲染问题
			const storedTheme = localStorage.getItem("theme") || DEFAULT_THEME;
			const isDark = storedTheme === DARK_MODE;
			const expectedTheme = isDark ? "github-dark" : "github-light";

			const currentTheme =
				document.documentElement.getAttribute("data-theme");
			const hasDarkClass =
				document.documentElement.classList.contains("dark");

			// 如果主题不匹配，使用批量更新减少重绘
			if (currentTheme !== expectedTheme || hasDarkClass !== isDark) {
				// 使用 requestAnimationFrame 批量更新，减少重绘
				requestAnimationFrame(() => {
					// 同步 data-theme 属性
					if (currentTheme !== expectedTheme) {
						document.documentElement.setAttribute(
							"data-theme",
							expectedTheme,
						);
					}
					// 同步 dark class
					if (hasDarkClass !== isDark) {
						if (isDark) {
							document.documentElement.classList.add("dark");
						} else {
							document.documentElement.classList.remove("dark");
						}
					}
				});
			}

			// 检查当前页面是否为文章页面，如果是则触发自定义事件用于初始化评论系统
			setTimeout(() => {
				if (document.getElementById("tcomment")) {
					// 触发自定义事件，通知评论系统页面已完全加载
					const pageLoadedEvent = new CustomEvent(
						"mizuki:page:loaded",
						{
							detail: {
								path: window.location.pathname,
								timestamp: Date.now(),
							},
						},
					);
					document.dispatchEvent(pageLoadedEvent);
					console.log(
						"Layout: 触发 mizuki:page:loaded 事件，路径:",
						window.location.pathname,
					);
				}
			}, 300);
		});

		window.swup.hooks.on("visit:end", (_visit: { to: { url: string } }) => {
			setTimeout(() => {
				const heightExtend =
					document.getElementById("page-height-extend");
				if (heightExtend) {
					heightExtend.classList.add("hidden");
				}

				// Just make the transition looks better
				const toc = document.getElementById("toc-wrapper");
				if (toc) {
					toc.classList.remove("toc-not-ready");
				}
			}, 200);
		});
	};

	if (window?.swup?.hooks) {
		initFancybox();
		checkKatex();
		setup();
	} else {
		document.addEventListener("swup:enable", setup);
		// 监听 DOM 加载 (确保首屏也能加载优化组件)
		if (document.readyState === "loading") {
			document.addEventListener("DOMContentLoaded", () => {
				initFancybox();
				checkKatex();
			});
		} else {
			initFancybox();
			checkKatex();
		}
	}

	let backToTopBtn = document.getElementById("back-to-top-btn");
	let toc = document.getElementById("toc-wrapper");
	let navbar = document.getElementById("navbar-wrapper");

	// 节流函数
	function throttle(func: Function, limit: number) {
		let inThrottle: boolean;
		return function (this: any) {
			const args = arguments;
			const context = this;
			if (!inThrottle) {
				func.apply(context, args);
				inThrottle = true;
				setTimeout(() => (inThrottle = false), limit);
			}
		};
	}

	function scrollFunction() {
		const scrollTop = document.documentElement.scrollTop;
		const bannerHeight = window.innerHeight * (BANNER_HEIGHT / 100);
		
		// 尝试获取内容区域的起始位置
		const contentWrapper = document.getElementById('content-wrapper');
		let showBackToTopThreshold = bannerHeight + 100; // 默认回退值

		if (contentWrapper) {
			const rect = contentWrapper.getBoundingClientRect();
			// 当 content-wrapper 的顶部接近视口顶部时显示
			// rect.top 是相对于视口的，当它小于视口高度的一半时，说明已经滚动到了内容区
			// 或者更简单：scrollTop > contentWrapper.offsetTop
			// 由于 offsetTop 是相对于 offsetParent 的，可能需要累加
			// 这里我们使用 getBoundingClientRect + scrollTop 来获取绝对位置
			const absoluteTop = rect.top + scrollTop;
			// 只有当滚动超过内容区域起始位置一定距离后才显示
			showBackToTopThreshold = absoluteTop + window.innerHeight / 4;
		}

		// 批量处理DOM操作
		requestAnimationFrame(() => {
			if (backToTopBtn) {
				// 使用动态计算的阈值
				if (scrollTop > showBackToTopThreshold) {
					backToTopBtn.classList.remove("hide");
				} else {
					backToTopBtn.classList.add("hide");
				}
			}

			if (bannerEnabled && toc) {
				const isBannerMode = document.body.classList.contains("enable-banner");
				if (isBannerMode) {
					if (scrollTop > bannerHeight) {
						toc.classList.remove("toc-hide");
					} else {
						toc.classList.add("toc-hide");
					}
				} else {
					// In Fullscreen or None mode, always show TOC
					toc.classList.remove("toc-hide");
				}
			}

			if (bannerEnabled && navbar) {
				const isHome =
					document.body.classList.contains("lg:is-home") &&
					window.innerWidth >= 1024;
				const currentBannerHeight = isHome
					? BANNER_HEIGHT_HOME
					: BANNER_HEIGHT;

				const threshold =
					window.innerHeight * (currentBannerHeight / 100) - 88;
				if (scrollTop >= threshold) {
					navbar.classList.add("navbar-hidden");
				} else {
					navbar.classList.remove("navbar-hidden");
				}
			}
		});
	}

	// 使用节流优化滚动性能
	window.onscroll = throttle(scrollFunction, 16); // 约60fps

	window.onresize = () => {
		// calculate the --banner-height-extend, which needs to be a multiple of 4 to avoid blurry text
		let offset = Math.floor(
			window.innerHeight * (BANNER_HEIGHT_EXTEND / 100),
		);
		offset = offset - (offset % 4);
		document.documentElement.style.setProperty(
			"--banner-height-extend",
			`${offset}px`,
		);
	};

	// 页面加载完成后初始化banner和轮播图
	if (document.readyState === "loading") {
		document.addEventListener("DOMContentLoaded", async () => {
			showBanner();
			// 初始化面板管理器
			try {
				await import("../utils/panel-manager.js");
				console.log("Panel manager initialized");
			} catch (error) {
				console.error("Failed to initialize panel manager:", error);
			}
		});
	} else {
		showBanner();
		// 页面已经加载完成，立即初始化面板管理器
		(async () => {
			try {
				await import("../utils/panel-manager.js");
				console.log("Panel manager initialized");
			} catch (error) {
				console.error("Failed to initialize panel manager:", error);
			}
		})();
	}
</script>

<!-- 代码块折叠功能 -->
<script>
	import "../scripts/code-collapse.js";
</script>

<!-- 主题切换综合性能优化器（包含代码块优化、重型元素优化、性能诊断） -->
<script>
	import "../scripts/theme-optimizer.js";
</script>
